<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FiberMind.AI</title>

  <!-- League Spartan font -->
  <link href="https://fonts.googleapis.com/css2?family=League+Spartan:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    :root {
      --bg: #f8f8f8;
      --fg: #000;
      --muted: #555;
      --blue: #00aaff;
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: "League Spartan", sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      position: relative;
      overflow: hidden;
    }
    .background-waves {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }
    .wrap {
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 24px;
      position: relative;
      z-index: 1;
    }
    .card {
      text-align: center;
      max-width: 860px;
      width: 100%;
    }
    h1 {
      font-size: 48px;
      line-height: 1.1;
      font-weight: 700;
      letter-spacing: 0.2px;
      margin: 0 0 20px 0;
    }
    .lines {
      font-size: 20px;
      line-height: 1.4;
      font-weight: 400;
      letter-spacing: 0.2px;
      display: grid;
      gap: 8px;
    }
    .hint {
      margin-top: 28px;
      font-size: 14px;
      color: var(--muted);
      letter-spacing: 0.3px;
    }
    .reveal {
      animation: glow 800ms ease-out both;
    }
    @keyframes glow {
      0%   { text-shadow: 0 0 0px rgba(0,0,0,0); }
      50%  { text-shadow: 0 0 8px rgba(0,0,0,0.2); }
      100% { text-shadow: 0 0 0px rgba(0,0,0,0); }
    }
  </style>
</head>
<body>
  <!-- Neon Wavy Background -->
  <svg class="background-waves" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 900" preserveAspectRatio="none">
    <defs>
      <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="8" result="blur"/>
        <feMerge>
          <feMergeNode in="blur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path d="M0,300 Q360,250 720,300 T1440,300" stroke="#00aaff" stroke-width="10" fill="none" filter="url(#glow)"/>
    <path d="M0,450 Q360,400 720,450 T1440,450" stroke="#00aaff" stroke-width="10" fill="none" filter="url(#glow)"/>
    <path d="M0,600 Q360,550 720,600 T1440,600" stroke="#00aaff" stroke-width="10" fill="none" filter="url(#glow)"/>
  </svg>

  <main class="wrap">
    <section class="card" aria-labelledby="site-title">
      <h1 id="site-title">FiberMind.AI</h1>
      <div class="lines" aria-live="polite">
        <p class="decrypt" data-final="We’re currently busy building"></p>
        <p class="decrypt" data-final="the first foundational ai for fiber sensing"></p>
        <p class="decrypt" data-final="interested?  deep.desai@fibermind.ai"></p>
      </div>
      <p class="hint" aria-hidden="true">© FiberMind.AI</p>
    </section>
  </main>

  <script>
    // Slower, smoother decrypt effect
    (function () {
      const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()[]{}<>?/\\|~";
      const lines = Array.from(document.querySelectorAll(".decrypt"));

      const stepDelay = 120;       // slower frame rate
      const perCharSteps = 12;    // more scramble frames per char
      const lineStagger = 100;    // ms between lines

      function scrambleTo(element, finalText) {
        const length = finalText.length;
        let frame = 0;
        return new Promise((resolve) => {
          const timer = setInterval(() => {
            const out = Array.from({ length }, (_, idx) => {
              const progress = frame / perCharSteps;
              const cutoff = Math.floor(progress * length);
              if (idx <= cutoff) {
                return finalText[idx];
              }
              return charset[Math.floor(Math.random() * charset.length)];
            }).join("");

            element.textContent = out;
            frame++;

            if (frame > perCharSteps) {
              element.textContent = finalText;
              element.classList.add("reveal");
              clearInterval(timer);
              resolve();
            }
          }, stepDelay);
        });
      }

      (async function run() {
        for (let i = 0; i < lines.length; i++) {
          const el = lines[i];
          const finalText = el.getAttribute("data-final") || "";
          el.textContent = finalText
            .split("")
            .map(ch => ch === " " ? " " : charset[Math.floor(Math.random() * charset.length)])
            .join("");
          await new Promise(r => setTimeout(r, i * lineStagger));
          await scrambleTo(el, finalText);
        }
      })();
    })();
  </script>
</body>
</html>
