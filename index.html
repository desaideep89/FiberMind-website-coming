<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>FiberMind.AI</title>

  <!-- League Spartan font -->
  <link href="https://fonts.googleapis.com/css2?family=League+Spartan:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      --bg:#f8f8f8;    /* glossy white with slight grey hint */
      --fg:#000;       /* black text */
      --muted:#666;
      --fiber-opacity:0.14; /* base visibility for fibers */
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:"League Spartan",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      overflow:hidden;
    }

    /* Canvas-based fiber background */
    .bg-fibers{
      position:fixed;
      inset:0;
      z-index:0;
      pointer-events:none;
      display:block;
    }

    .wrap{
      min-height:100%;
      display:grid;
      place-items:center;
      padding:24px;
      position:relative;
      z-index:1;
      text-align:center;
    }
    h1{
      font-size:48px;
      font-weight:700;
      line-height:1.1;
      margin:0 0 20px 0;
      letter-spacing:.2px;
    }
    .lines{
      font-size:20px;
      font-weight:400;
      line-height:1.4;
      letter-spacing:.2px;
      display:grid;
      gap:8px;
    }
    .hint{
      margin-top:28px;
      font-size:14px;
      color:var(--muted);
      letter-spacing:.3px;
    }
    .reveal{ animation: glow 800ms ease-out both; }
    @keyframes glow{
      0%{ text-shadow:0 0 0 rgba(0,0,0,0); }
      50%{ text-shadow:0 0 8px rgba(0,0,0,.15); }
      100%{ text-shadow:0 0 0 rgba(0,0,0,0); }
    }
  </style>
</head>
<body>

  <!-- Canvas: static wavy dark-gray fibers + red neon-ish pulses (FIFO, one at a time, uniform speed) -->
  <canvas class="bg-fibers" id="fibers"></canvas>

  <main class="wrap">
    <section aria-labelledby="site-title">
      <h1 id="site-title">FiberMind.AI</h1>
      <div class="lines" aria-live="polite">
        <p class="decrypt" data-final="We’re currently busy building"></p>
        <p class="decrypt" data-final="The First Foundational AI For Fiber Sensing"></p>
        <p class="decrypt" data-final="Interested?  deep.desai@fibermind.ai"></p
      </div>
      <p class="hint" aria-hidden="true">© FiberMind.AI</p>
    </section>
  </main>

  <script>
    // ---------------------------------------------
    // Static wavy fibers + FIFO pulse (uniform speed)
    // Pulses made smaller & more background-oriented.
    // ---------------------------------------------
    (function(){
      const canvas = document.getElementById('fibers');
      const ctx = canvas.getContext('2d');

      let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      let W = 0, H = 0;

      function resize(){
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width  = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        canvas.style.width  = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);
        buildStaticPaths(); // rebuild fiber geometry on resize so it stays crisp
      }
      window.addEventListener('resize', resize, { passive:true });

      // --------- TUNING KNOBS ----------
      const PULSE_SPEED = 1.28;   // fraction of the viewport width per second (uniform speed for ALL pulses)
      const queueGapMs  = 350;    // wait between pulses after one exits (per fiber, FIFO)
      // ---------------------------------

      // Colors
      const fiberColor = {r:80, g:80, b:80};    // dark gray fibers
      // Red pulse, but toned down (more background): lower alpha and softer glow
      const pulseA = {r:255, g:80,  b:80};      // neon red base
      const pulseB = {r:255, g:0,   b:0};       // deep red
      const pulseC = {r:255, g:120, b:120};     // pinkish red highlight

      const fiberOpacity = 0.14;                // subtle fibers
      const pulseAlphaLow   = 0.25;             // reduced from ~0.45
      const pulseAlphaHigh  = 0.60;             // reduced from ~1.00
      const pulseGlowAlpha  = 0.35;             // softer outer glow
      const pulseGlowBlur   = 6;                // smaller blur
      const pulseThicknessBoost = 1.0;          // thinner streak (was +2); ~half look

      function lerp(a,b,t){ return a + (b-a)*t; }

      // Fiber shape parameters (static, wavy)
      const N = 9;                  // number of fibers
      const thicknessMin = 0.8;     // px
      const thicknessMax = 1.4;     // px
      const amps = [];              // per-fiber amplitude (px)
      const freqs = [];             // per-fiber frequency (spatial)
      const phases = [];            // per-fiber initial phase
      const baseYs = [];            // per-fiber baseline y (px)
      const thicknesses = [];
      const sampleX = [];           // shared sample X positions for path rendering
      const pathY = [];             // [fiberIndex][i] -> y for that x sample

      // Pulse queues (FIFO) per fiber
      const queues = [];            // array of arrays of pulse configs
      const active = [];            // active pulse per fiber or null
      const cooldown = [];          // ms delay before next pulse starts

      function makePulse(){
        // All pulses use the same global speed; vary only length/strength slightly.
        return {
          pos: -0.12,                        // start off-screen to the left
          length: lerp(0.06, 0.09, Math.random()), // slightly shorter to feel smaller
          strength: lerp(0.55, 0.80, Math.random())
        };
      }

      function buildStaticPaths(){
        // Seed geometry for static wavy lines
        amps.length = 0; freqs.length = 0; phases.length = 0; baseYs.length = 0; thicknesses.length = 0;
        const rng = Math.random;
        for(let i=0;i<N;i++){
          const t = i/(N-1);
          baseYs[i] = (0.18 + 0.64*t) * H;
          amps[i]   = lerp(10, 20, rng());       // slightly calmer wave height
          freqs[i]  = lerp(1.1, 1.7, rng());     // spatial frequency
          phases[i] = rng() * Math.PI * 2;       // static phase
          thicknesses[i] = lerp(thicknessMin, thicknessMax, rng());
        }

        // Build sampled X coordinates and per-fiber Y paths
        const samples = Math.max(160, Math.floor(W/10)); // decent resolution
        sampleX.length = 0;
        for(let i=0;i<=samples;i++){
          sampleX.push((i/samples) * W);
        }
        pathY.length = 0;
        for(let f=0; f<N; f++){
          const row = [];
          for(let i=0;i<sampleX.length;i++){
            const x = sampleX[i];
            // Two-harmonic static wave for glassy feel
            const y = baseYs[f]
              + amps[f] * Math.sin((2*Math.PI/W) * freqs[f] * x + phases[f])
              + 0.5*amps[f] * Math.sin((2*Math.PI/W) * freqs[f] * 0.5 * x + phases[f]*0.8 + 1.7);
            row.push(y);
          }
          pathY.push(row);
        }

        // Initialize queues once
        if (queues.length === 0){
          for(let f=0; f<N; f++){
            queues[f] = [makePulse(), makePulse(), makePulse()]; // a few queued pulses per fiber
            active[f] = null;
            cooldown[f] = 0;
          }
        }
      }

      function yAtFraction(fiberIndex, frac){
        // frac is 0..1 along width, sample with interpolation from pathY
        if (frac <= 0) return pathY[fiberIndex][0];
        if (frac >= 1) return pathY[fiberIndex][pathY[fiberIndex].length-1];
        const idx = frac * (pathY[fiberIndex].length-1);
        const i0 = Math.floor(idx);
        const i1 = Math.min(i0+1, pathY[fiberIndex].length-1);
        const t  = idx - i0;
        return pathY[fiberIndex][i0]*(1-t) + pathY[fiberIndex][i1]*t;
      }

      function drawFiberLine(fiberIndex){
        ctx.beginPath();
        const yrow = pathY[fiberIndex];
        ctx.moveTo(sampleX[0], yrow[0]);
        for(let i=1;i<sampleX.length;i++){
          ctx.lineTo(sampleX[i], yrow[i]);
        }
        ctx.strokeStyle = `rgba(80,80,80,${parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fiber-opacity')) || 0.14})`;
        ctx.lineWidth = thicknesses[fiberIndex];
        ctx.lineCap = 'round';
        ctx.shadowColor = 'rgba(0,0,0,0)';
        ctx.shadowBlur = 0;
        ctx.stroke();
      }

      function drawPulse(fiberIndex, p, dt){
        // p.pos is 0..1 along width; we draw a streak [x0..x1] along the static path
        p.pos += PULSE_SPEED * dt; // uniform speed for ALL pulses
        const half = (p.length) * 0.5;
        const x0f = p.pos - half;
        const x1f = p.pos + half;

        // If completely offscreen to the right, signal completion
        if (x0f > 1.02) return 'done';

        // Clamp visible part and skip if invisible
        const vis0 = Math.max(0, x0f);
        const vis1 = Math.min(1, x1f);
        if (vis1 <= 0 || vis0 >= 1) return;

        const x0 = vis0 * W;
        const x1 = vis1 * W;

        // Build gradient along the streak (lower alphas to push into background)
        const y0 = yAtFraction(fiberIndex, vis0);
        const y1 = yAtFraction(fiberIndex, vis1);
        const grad = ctx.createLinearGradient(x0, y0, x1, y1);

        grad.addColorStop(0.00, `rgba(${pulseA.r},${pulseA.g},${pulseA.b},0)`);
        grad.addColorStop(0.25, `rgba(${pulseA.r},${pulseA.g},${pulseA.b},${pulseAlphaLow * p.strength})`);
        grad.addColorStop(0.50, `rgba(${pulseC.r},${pulseC.g},${pulseC.b},${pulseAlphaHigh * p.strength})`);
        grad.addColorStop(0.75, `rgba(${pulseA.r},${pulseA.g},${pulseA.b},${pulseAlphaLow * p.strength})`);
        grad.addColorStop(1.00, `rgba(${pulseB.r},${pulseB.g},${pulseB.b},0)`);

        ctx.strokeStyle = grad;
        // ~half the prior thickness
        ctx.lineWidth = Math.max(1.4, thicknesses[fiberIndex] + pulseThicknessBoost);
        ctx.lineCap = 'round';
        ctx.shadowColor = `rgba(255,0,0,${pulseGlowAlpha})`;
        ctx.shadowBlur = pulseGlowBlur;

        // Draw as a segmented polyline following the path
        ctx.beginPath();
        const segs = 28;
        for(let i=0;i<=segs;i++){
          const f = vis0 + (i/segs)*(vis1 - vis0);
          const x = f * W;
          const y = yAtFraction(fiberIndex, f);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.shadowBlur = 0;
      }

      function stepPulses(dtMs){
        const dt = dtMs / 1000; // seconds
        // Manage FIFO logic per fiber: only one active pulse at a time
        for(let f=0; f<N; f++){
          if (active[f]){
            const res = drawPulse(f, active[f], dt);
            if (res === 'done'){
              active[f] = null;
              cooldown[f] = queueGapMs; // wait a bit before next pulse
            }
          } else if (cooldown[f] > 0){
            cooldown[f] -= dtMs;
            if (cooldown[f] < 0) cooldown[f] = 0;
          } else if (queues[f].length > 0){
            // Pop next pulse and activate (FIFO)
            const next = queues[f].shift();
            // start from just offscreen left, keep same global speed
            next.pos = -next.length;
            active[f] = next;
            // Refill queue so pulses keep coming in FIFO order
            queues[f].push(makePulse());
          }
        }
      }

      // Build once and start loop
      resize();
      let last = performance.now();
      function loop(ts){
        const now = ts;
        const dtMs = Math.min(50, now - last); // cap delta for stability
        last = now;

        // Clear frame
        ctx.clearRect(0,0,W,H);

        // Draw static fibers
        for(let f=0; f<N; f++) drawFiberLine(f);

        // Advance and draw pulses (FIFO, uniform speed)
        stepPulses(dtMs);

        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    })();

    // ---------------------------------------
    // Slow decrypt effect — all lines together
    // ---------------------------------------
    (function () {
      const charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()[]{}<>?/\\|~";
      const lines = Array.from(document.querySelectorAll(".decrypt"));
      const stepDelay = 70;    // frame interval (ms)
      const perCharSteps = 18; // scramble frames per character

      function scrambleTo(element, finalText) {
        const length = finalText.length;
        let frame = 0;
        return new Promise((resolve) => {
          const timer = setInterval(() => {
            const progress = frame / perCharSteps;
            const cutoff = Math.floor(progress * length);
            const out = Array.from({ length }, (_, idx) => {
              if (idx <= cutoff) return finalText[idx];
              const ch = finalText[idx];
              return ch === " " ? " " : charset[Math.floor(Math.random() * charset.length)];
            }).join("");

            element.textContent = out;
            frame++;

            if (frame > perCharSteps) {
              element.textContent = finalText;
              element.classList.add("reveal");
              clearInterval(timer);
              resolve();
            }
          }, stepDelay);
        });
      }

      (async function runTogether() {
        lines.forEach(el => {
          const finalText = el.getAttribute("data-final") || "";
          el.textContent = finalText.split("")
            .map(ch => ch === " " ? " " : charset[Math.floor(Math.random() * charset.length)])
            .join("");
        });
        await Promise.all(
          lines.map(el => scrambleTo(el, el.getAttribute("data-final") || ""))
        );
      })();
    })();
  </script>
</body>
</html>
